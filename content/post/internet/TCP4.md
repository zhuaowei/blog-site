---
title: "TCP 的拥塞控制"
date: 2022-11-01T16:38:20+08:00
draft: false
math: true

tags: ["计算机网络", "运输层", "TCP", "拥塞控制"]
categories: ""
description: "传输控制协议 TCP 系列（其四）"
---

## 1、TCP 的拥塞控制

### 1.1、拥塞控制的一般原理

**1、拥塞的定义**

**拥塞（congestion）**：网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏。

拥塞是一个复杂的问题，它并不是增加某一个资源就能解决的。

**2、造成拥塞的因素**

1.   某个节点的缓存容量不足，无法暂存分组，只得丢弃分组。
2.   节点的处理机的处理速度太慢。
3.   输出链路的容量不足。

只提高上面某一项资源是不足以解决拥塞问题的。例如只增大缓存容量，到达节点的分组会逐渐增多，不过不增大处理速度和输出容量，缓存迟早会占满。另外两项同理。

拥塞还有一个特点，就是常常会趋于恶化。例如，某个分组因拥塞而被丢弃，那么发送方就会重传这一分组，可能还会重传多次。

**3、拥塞控制**

**拥塞控制**：防止过多的主矩注入到网络中，这样可以是网络中的路由器或链接不致过载。即网络能够承受现有的网络负荷。

>   拥塞控制和流量控制的区别：
>
>   流量控制是端到端的通信量的控制，只涉及发送和接收两方的主机。
>
>   拥塞控制是一个全局性的过程，涉及到网络中所有的主机，路由器等与拥塞有关的因素。

**4、负载与吞吐量的关系**

**提供的负载（offered load）**：单位时间内输入给网络的分组的数量。

**吞吐量（throughput）**：单位时间内从网络输出分组的数量。

理想状态下，在某一限度内，吞吐量和负载是相等的，当超过一定限度，吞吐量就会达到饱和，不再变化。

实际上，不设置拥塞控制的情况下，在网络还未到达所说的限度时，就已经开始拥塞，即输入的负载大于输出的吞吐量。当吞吐量明显小于理想的吞吐量时，网络就进入了**轻度拥塞状态**。当提供的负载达到某一数值时，吞吐量不增反降，网络就进入到了**拥塞状态**。当负载继续增大，直到吞吐量下降到零，网络就进入到了**死锁状态**。

在有拥塞控制的网络中，吞吐量会随着提供的负载增大而增大，但永远不会到达理想的吞吐量。

**5、拥塞控制的设计**

拥塞控制有两种方法，**开环控制**和**闭环控制**。

**开环控制**：实现将所有的拥塞的因素都考虑到，避免发生拥塞，一旦整个系统运行，就不再中途修改。

**闭环控制**：基于反馈环路的概念，主要有以下几种措施：

1.   监测网络系统，以便检测拥塞何时，何处发生。
2.   把拥塞发生的信息传送到可采取行动的地方。
3.   调整网络系统的运行以解决出现的问题。

为了监测网络拥塞，需要选择一些指标，例如丢弃分组的百分比，平均分组时延，平均队列长度，超时重传的分组数等等。

一般会将拥塞的信息传送到产生分组的源站，但这会加剧拥塞，另一种方式是在转发分组保留一个字段或比特，表示是否产生拥塞。还可以由一些主机和路由周期性地发出探测分组，询问是否发生拥塞。

### 1.2、TCP 的拥塞控制方法

TCP 使用四种拥塞控制算法：**慢开始（slow-start）**，**拥塞避免(congestion avoidance)**，**快重传（fast retransmit）**，**快恢复（fast recovery）**。

现在假设：数据传输是单方面的，接收方有充足空间接收数据，发送窗口由拥塞程度决定。

**1、慢开始和拥塞避免**

**拥塞窗口cwnd（congestion window）**：发送方维持的一个状态变量，取决于网络的拥塞程度，并动态变化。因为接收方的空间无限大，所以就**让发送方的发送窗口等于拥塞窗口**。

如何判断网络是否发生拥塞？**依据就是出现超时**。

**慢开始**：刚开始发送的时候，并不知道网络的状况，为了防止数据输入过多而发生拥塞，就先试探一下，即**由小到大逐渐增大发送窗口**，也即**由小到大逐渐增大拥塞窗口的数值**。

>   1.   **SMSS（Sender Maximum Segment Size）**：发送方最大发送报文段。
>
>   2.   拥塞窗口的单位是字节，这里为了方面说明，将 SMSS 作为拥塞窗口的单位

在刚开始发送时，把初始拥塞窗口设置为 1 至 2 个 SMSS。新规定是不超过 2 - 4 个 SMSS。

1.   若 SMSS > 2190 字节：不得超过 2 个 SMSS。
2.   若 SMSS > 1095 字节：不得超过 3 个 SMSS。
3.   若 SMSS <= 1095 字节：不得超过 4 个 SMSS。

每收到一个**对新的报文段的确认**后，就可以把拥塞窗口增加最多一个 SMSS 的数值。
$$
拥塞窗口 cwnd 每次的增加量 = min(N, SMSS)
$$
N 是原先未被确认、但现在被刚收到的确认报文所确认的字节数。

每经过一个传输轮次，拥塞窗口 cwnd 就加倍。

```
         发送方                           接收方
cwnd = 1   |                               |
           | ----------------------------> | 传输 1 个报文
           | <---------------------------- | 轮次1
cwnd = 2   |
           | ----------------------------> | 传输 2 个报文
           | <---------------------------- | 轮次2
cwnd = 4   |
           | ----------------------------> | 传输 4 个报文
           | <---------------------------- | 轮次3
cwnd = 8
```

**慢开始门限（ssthresh）**：为了防止拥塞窗口增长过大而引起网络拥塞，需要设置一个慢开始门限。

1.   cwnd < ssthresh：使用慢开始算法。
2.   cwnd > ssthresh：停止使用慢开始算法，使用拥塞避免算法。
3.   cwnd = ssthresh：即可使用慢开始算法，也可使用拥塞避免算法。

**2、拥塞避免**

拥塞避免是让拥塞窗口缓慢增大，每经过一个往返时间 RTT 就把发送方的拥塞窗口加 1（**加法增大**）。

当网络中出现超时，发送方判断为网络拥塞。于是调整门限值 `ssthresh = cwnd / 2`，同时设置拥塞窗口 `cwnd = 1`，进入慢开始阶段。

**3、快重传**

当发送方连续收到 3 个来自同一报文的确认时，说明不是网络发生了拥塞，而是自己发送的报文丢失了，需要尽快重传。

快重传要求**接收方要立即发送确认**，即使收到的报文是失序的，不能等到发送数据时捎带确认。

**4、快恢复**

当发送方收到了上面情况的报文，发送方就知道只是丢失了个别的报文，于是就执行快恢复算法。调整门限值 `ssthresh = cwnd / 2`，同时设置 `cwnd = ssthresh`，并开始拥塞避免算法。

从上面可以看出，拥塞避免阶段拥塞窗口值是线性增长，也叫**加法增大AI（additive Increase）**。而一旦超时或者收到 3 个重复确认就要降低门限值为原来的一半，并大大减小拥塞窗口的值，这也叫**乘法减小MD（Multiplication Decrease）**。

上面的算法是假设接收方有足够的空间接收报文段，只考虑了拥塞窗口。现实情况下，**发送方的发送窗口也不能超过接收方给出的接收窗口值 rwnd**。所以：
$$
发送窗口的上限值 = Min[rwnd, cwnd]
$$

### 1.3、主动队列管理 AQM

网络层采取的策略与 TCP 拥塞控制的关系：如果网络中某一个路由器的处理时间特别长，导致这个啊勃文超时重传，TCP 就认为网络中发生了拥塞，实际上并没有。

**尾部丢弃策略（tail-drop policy）**：路由器按照先进先出的规则处理收到的分组，如果队列已经满了，那么排在队列尾部的分组就会被丢弃。

如果采用尾部丢弃策略，丢弃尾部往往会导致一连串分组的丢失，发送方的 TCP 就会进入慢开始状态。如果尾部丢弃一下导致很多 TCP 连接进入慢开始状态，这种情况被称为全局同步（global synchronization）。网络恢复后，通信量会突然大增。

为了避免全局同步现象，提出了 **主动队列管理AQM（active Queue Management）**。在队列出现某种拥塞征兆时就主动丢弃到达的分组。实现方法有很多，流行的是**随机早期检测RED（Random Early Detection）**。

实现 RED 要维持两个变量：队列长度最小门限和最大门限。当分组到达时：

1.   若平均队列长度小于最小门限，新到的分组入队。
2.   若平均队列长度大于最大门限，新到的分组丢弃。
3.   若平均队列长度在最小门限和最大门限之间，按照某一丢弃概率 p 丢弃。（随机性）

最难处理的就是概率 p 的选择，对于每个分组都要计算丢弃概率 p。

事实证明 RED 效果不太理想，但是 AQM 是必要的，代替 RED 的算法都正在实验中。