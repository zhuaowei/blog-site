---
title: "运输层——传输控制协议 TCP（其二）"
date: 2022-10-31T21:21:51+08:00
draft: false
math: true

tags: ["计算机网络", "运输层", "TCP"]
categories: ""
description: "TCP 可靠传输的实现"
---

## 1、TCP 可靠传输的实现

为了方便描述，假定数据传输只有一个方向。A 发送数据，B 发送确认。

### 1.1、以字节为单位的滑动窗口

**1、发送窗口**

假如 A 收到了 B 发来的确认报文，报文内容是：`ack = 31, cwnd = 20`，这说明：B 已经收到了序号为 30 之前的报文了，期待发送的是序号为 31 的报文，窗口大小是 20，也就是 A 能发送序号为 31 - 50 的报文，这个范围就是 A 的**发送窗口**。

发送窗口里是允许发送且不需要确认的报文，这些报文在**没有收到确认之前都要保留**，以防超时重发。

收到确认报文后，确认序号前的报文就都可以释放了，然后 A 的发送窗口就可以向前移动，但是不能超过 B 的窗口值。

接收方也有一个接收窗口，接收窗口和发送窗口是一样的，接收方只对**按序到达的最后一个报文**发送确认。

例如：接收方发送了 `ack = 31, cwnd = 20`，此时接收窗口就是 31 - 50，31 之前的已经交付给主机并释放掉了。这是 A 发来了序号为 32， 33，的报文，B 不能发送 `ack = 34` 的报文，只能发送 `ack = 31` 的报文，因为他们不是按序到达的。如果 A 又发来了序号为 31，37， 38， 40的报文，B 可以发送 `ack = 34` 的报文。当 A 收到这个确认报文后就可以将发送窗口向前移动 3 个位置了。

```
|29|30|31|32|33|34|35|36|37|38|39|40|41|42|43|44|45|46|47|48|49|50|51|52|53|54|55|
        ^                               ^                       ^
        |p1 <------- 已发未确认 -------> |p2 <---- 允许但未发 ---->|p3
        |  <--------------------- 发送窗口 ------------------->  |
```

A 在发送时，P2指针会一直向前移动，直到与 p3 重合，但不会超过 p3。如果 p2、p3 重合，就必须停止发送，在超时计时器到时间后，就要重新发送未确认的报文，然后重置超时计时器，如此循环，直到收到 B 的确认报文。

**2、发送缓存和接收缓存**

发送方的应用程序把字节流写入 TCP 的发送缓存，接收方的应用进程从接收缓存中读取字节流。

关于发送缓存和接收缓存：

1.   它们的空间都是有限的，且是循环使用的。
2.   实际缓存或这窗口的字节数都是很大的。

**3、发送缓存**

1.   存放应用程序传送给发送方 TCP 的准备发送的数据：
2.   存放 TCP 已经发送但是尚未收到确认的数据。1 包含 2

发送窗口是发送缓存的一部分。已经确认的数据应当从缓存中删除。应用程序不应当发送过快，否则会没有空间存放数据。

**4、接收缓存**

1.   存放收到的数据
2.   存放未被应用程序读取的数据（按序到达的部分）。

如果收到的分组被检测到有差错就要丢弃。

如果应用程序来不及读取到达的数据，那么缓存最终就会被填满，接收窗口就会减小到0；反之，缓存空间就会变大，接收窗口也会变大，但是不会超过缓存。

**5、注意**

1.   虽然发送窗口是由接收窗口设置的，但是统一时刻，这两个窗口是可能不一样的，因为网络传输有延迟。
2.   对于不按序到达的数据，没有明确处理方式，接收方可以完全丢弃，但是浪费资源，一般是临时存储到接收窗口中，然后**按序上交到应用程序**。
3.   TCP 要求接收方必须有累积确认的功能，这样可以减少开销。接收方也可以在合适的时候发送确认，也可以在发送数据时**捎带确认信息**。
4.   确认推迟的时间不得超过 0.5 秒。如果收到一连串最大长度的报文端，必须每隔一段时间发送一个确认。
5.   捎带确认信息的情况不常见，因为很少有双向发送的情况。

### 1.2、超时重传时间的选择

超时重传时间对网络的影响：时间太短，引起不必要的重传，增大网络开销；时间太长，网络利用率减小，传输效率降低。

**1、超时重传时间**

**报文段的往返时间 RTT**：发送一个报文，记录它的发送时间，和收到相应确认报文的接收时间。这个时间差就是报文段的往返时间 RTT。

TCP 保留了一个 RTT 的**加权平均返回时间 RTTs（S表示Smoothed，因为加权使它更平滑）**，每次测到新的 RTT 样本时，就计算一下新的 RTTs。
$$
新的 RTT_s = (1 - \alpha) \times (旧的 RTT_s) + \alpha \times (新的 RTT 样本)
$$
$0 \le \alpha \lt 1$，当 $\alpha$ 很接近 0，新的 RTTs 和旧的 RTTs 变化不大，（RTT 值更新较慢）；当 $\alpha$ 接近 1，RTTs 受 RTT 的影响较大，（RTT 值更新较快）。官方建议的 $\alpha$ 的值是 $\frac{1}{8}$，也就是 0.125。

**超时重传时间 RTO（RetransmissionTime-Out）**:
$$
RTO = RTT_s + 4 \times RTT_D
$$
$RTT_D$ 是 RTT 的偏差的加权平均值，它与 $RTT_s$ 和新的 RTT 样本之差有关。建议使用下面的公式计算：
$$
新的 RTT_D = (1 - \beta) \times (旧的 RTT_D) + \beta \times \lvert RTT_s - 新的 RTT 样本 \rvert
$$
$\beta$ 是一个小于 1 的系数，它是推荐值是 $\frac{1}{4}$，也就是 0.25。

**2、重传确认时间**

如果确认报文丢失，超时后重传计算的超时重传时间会明显增大。如果从重传后开始计算时间，碰到确认延迟的情况，刚重传就收到了确认报文，超时重传时间就会明显减小，这样又会导致更多的报文重传。

因此，Karn 提出一个算法：在计算加权平均 RTTs 时，**只要报文段重传了，就不采用其往返时间样本**。这样计算出的加权平均 RTTs 和 RTO 就比较准确。

但是，这样又会出现新的问题，当网络延时突然增大，规定时间内收不到确认报文，刚刚发出的报文就需要重新发送，然而这些重发的报文是不计入往返时间样本的，这就导致 RTTs 和 RTO 就无法更新。

所以要对上面的算法修正：每次重传，就将超时重传时间 RTO 增大为原来的 2 倍。

### 1.3、选择确认 SACK

当接收方收到了报文无差错，只是没有按序号，接收方是不能发送确认报文的，发送方能否只重发按序到达中缺少的那部分报文？答案是可以。

例如：接收方收到了几段不连续的报文

```
|1--------1000|         |1501--------3000|       |3501--------4500|
|             |         |L1              |R1     |L2              |R2
# 边界信息
L1 = 1501, R1 = 3001
L2 = 3501, R2 = 4501
```

如果要准确告诉对方这些信息，就要使用**选择确认SACK描述这些信息**。如果使用这个功能，双方一开始就要约定好使用这个选项，原来的 ACK 功能不变。因为 TCP 的首部选项最多只能有 40 字节，所以 SACK 应该按如下安排：

1.   SACK：1 个字节，指明使用SACK。

2.   选项长度：1 个字节，指明选项的长度。

3.   边界信息：一个字节块有 2 个边界，一个边界需要 4 个字节，所以最多可以有 4 个字节块的边界信息。