---
title: "最长回文子串求法Manacher"
date: 2022-11-17T17:07:19+08:00
draft: false
math: false

tags: ["算法", "最长回文子串", "Manacher"]
categories: ""
description: ""
---

## 1、回文子串

回文就是正着读和反着读是一样的，例如 `abcba` 反过来还是 `abcba`，`abba` 反过来也是 `abba`。

回文子串就是字符串中某段连续的子串是回文，子串必须是连续的。

如何求回文呢，如果是暴力解法，用某一个字符作为对称轴，然后不断向两边比对延伸。这种方法不仅慢，而且还有一个问题，就是无法找到长度为偶数的回文，编程上也很难实现。

更好的方法是 Manacher 方法，它是在原来字符串的基础上，在字符之间和头尾添加字符，可以使用原字符串的字符作为对称轴，找到单数长度的；也可以使用插入的字符作为对称轴，找到双数长度的。例如：

```
              |
abcba -> #a#b#c#b#a#。
              |
abba  ->  #a#b#b#a#
              |
```

添加的字符有什么要求吗，答案是没有。无论添加什么字符。都不会影响结果。因为比对时，始终是原字符和原字符比，虚字符和虚字符比（虚字符：添加的）。

这个时候再用暴力解法就会比原来方便，得出的结果只需除以 2 即可。例如第一个字符串 长度是 11，原字符串是 5；第二个字符串长度是 9，原字符串是 4。

## 2、Manacher 加速

有没有什么办法，类似 KMP 算法，让对比的速度加快，也就是利用已经比对过的信息，省去一些不必要的比对。其实就是利用 Manacher 算法。

先来了解几个概念：

1. 回文中心：回文对称轴所在的位置。因为对原字符串处理过，回文中心一定是整数。
2. 回文直径：回文的长度
3. 回文半径：回文中心到回文边界的长度。

我们使用一个整数数组将其存储起来，表示 i 位置的回文半径为 pArr[i]。同时我们记录一下 i 位置之前的回文达到最右的情况的信息（回文中心C，右边界R），那么相应的左边界为 L。

如果在对比以某字符为中心的回文时，在这之前已经有前面字符的回文中心、半径信息，我们可能会遇到下面两种情况：

1、要比对的回文字符中心 i，在之前的最大右边界之外：我们得不到任何有用的信息，暴力解法，一个一个比对。例如下面的情况：

```
   L   C   R   i
...[...C...]...x
```

2、如果要比对的回文字符中心 i，在之前的最大右边界之内：这个时候，根据 i 的位置又分 3 种情况。
    
    2.1、第一种情况，如果以 C 为中心的 i 的对称点 i'，这个位置的回文完全在 [L, R] 之内，那么位置 i 的回文串长度必定与之相等。

    ```
       L                 C                 R
    ...[.................C.................]...
        ...m(...x...)n... ...p(...x...)q...
                i'                i
    ```
    为什么必定呢？因为 m != n，并且根据关于 C 对称的，m == q,n == p,那么 p != q，所以 i 位置的回文肯定是 pArr[i'] 这么长，不会多。

    2.2、第二种情况，如果以 C 为中心的 i 的对称点 i'，这个位置的回文一部分出现在 [L, R] 之外，那么 i 位置的回文长度也一定不会超过 R - i。

    ```
       L              C           R
    ......[...........C...........]......
    ...m(...x...)...     ...(...x...)q...
            i'                ( i )
    ```
    如图，小括号是 i 和 i' 回文串对应的范围，但是 i 位置的回文串肯定不是括号标识的那么长，它肯定不会超过 [L, R] 的右边界。因为如果超过了右边界 R，那么 m == q，那么 [L - 1, R + 1] 也肯定是回文串，因为它不是，所以 m != q，i 位置的回文串半径肯定是 R - i。

    2.3、第三种情况，如果以 C 为中心的 i 的对称点 i'，这个位置的回文的左边界与 L 重合，只能确定 i 位置的回文串至少等于 i' 位置的回文串。

    ```
       L            C            R
    ...[............C............]...
      m(...x...)n       p(...x...)q
           i'                i
    ```
    从上面看出：m != n, n == p, m != q. 而 p == q? 这个并不知道，还要继续往下比对。

## 3、Java代码实现

下面的代码实现与上面的有两点不同：

一是 R 的定义，下面的 R 比上面的大 1，为了方便写代码。原来的 R 是 回文串中心位置 + 半径 - 1；现在的 R 不用减 1.

二是不会将第二种情况一一进行分类处理，当然实际上是可以的。统一处理的好处是代码简洁。例如 for 循环中第一行代码，实际上是获取 i 位置回文串的中暂时的半径，`i + pArr[i]` 和 `i - pArr[i]` 实际上就是下一个需要进行比对的位置。即使知道其中有两种情况不需要比对，实际上他们比对一下就会跳出 while 循环，但这样做简化了代码。

```java
public static int getMaxLcpsString(String s) {

    // 将字符串转换成 manacher 字符串
    char[] str = getManacherString(s);
    // i 位置的回文半径
    int[] pArr = new int[str.length];
    // R: 回文到达的最远位置 + 1；C: 到达最远位置时回文中心。
    int R = -1, C = -1;
    int max = Integer.MIN_VALUE;
    for (int i = 0; i < str.length; i++) {
        /** 计算出不需要验证的范围
        * 1、i 超出 R，设置为 1，因为自身不需要验证
        * 2、i 在 R 范围内，选择范围最小的
        *      2.1、如果完全在内部，pArr[2 * C - i]
        *      2.2、如果在外部或者压线，R - i
        */
        pArr[i] = i < R ? Math.min(R - i, pArr[2 * C - i]) : 1;

        /**
        * 除了 i 不在 R 内和 i 在 R 内且边界重合的情况需要扩
        * 另外两种，因为直到肯定扩不成，但是还是放在一起写，简化代码
        */
        while (i + pArr[i] < str.length && i - pArr[i] > -1) {
            if (str[i + pArr[i]] == str[i - pArr[i]]) {
                pArr[i]++;
            } else {
                break;
            } 
        }
        // 如果超过了原来边界，更新
        if (i + pArr[i] > R) {
            R = i + pArr[i];
            C = i;
        }
        max = Math.max(max, pArr[i]);
    }
    return max - 1;
}

public static char[] getManacherString(String s) {
    char[] str = new char[s.length() * 2 + 1];
    char[] os = s.toCharArray();
    for(int i = 0; i < str.length; i++) {
        // 偶数位置插入 #；奇数位置插入原字符，因为数组边长了，所以要除以 2.
        str[i] = i % 2 == 0 ? '#' : os[i / 2];
    }
    return str;
}
```